{"version":3,"file":"v8n.min.js","sources":["../src/Rule.js","../src/Modifier.js","../src/ValidationError.js","../src/Context.js","../src/v8n.js"],"sourcesContent":["class Rule {\n  constructor(name, fn, args, modifiers) {\n    this.name = name;\n    this.fn = fn;\n    this.args = args;\n    this.modifiers = modifiers;\n  }\n\n  _test(value) {\n    let fn = this.fn;\n\n    try {\n      testAux(this.modifiers.slice(), fn)(value);\n    } catch (ex) {\n      fn = () => false;\n    }\n\n    try {\n      return testAux(this.modifiers.slice(), fn)(value);\n    } catch (ex) {\n      return false;\n    }\n  }\n\n  _check(value) {\n    try {\n      testAux(this.modifiers.slice(), this.fn)(value);\n    } catch (ex) {\n      if (testAux(this.modifiers.slice(), it => it)(false)) {\n        return;\n      }\n    }\n\n    if (!testAux(this.modifiers.slice(), this.fn)(value)) {\n      throw null;\n    }\n  }\n\n  _testAsync(value) {\n    return new Promise((resolve, reject) => {\n      testAsyncAux(\n        this.modifiers.slice(),\n        this.fn,\n      )(value)\n        .then(valid => {\n          if (valid) {\n            resolve(value);\n          } else {\n            reject(null);\n          }\n        })\n        .catch(ex => reject(ex));\n    });\n  }\n}\n\nfunction pickFn(fn, variant = 'simple') {\n  return typeof fn === 'object' ? fn[variant] : fn;\n}\n\nfunction testAux(modifiers, fn) {\n  if (modifiers.length) {\n    const modifier = modifiers.shift();\n    const nextFn = testAux(modifiers, fn);\n    return modifier.perform(nextFn);\n  } else {\n    return pickFn(fn);\n  }\n}\n\nfunction testAsyncAux(modifiers, fn) {\n  if (modifiers.length) {\n    const modifier = modifiers.shift();\n    const nextFn = testAsyncAux(modifiers, fn);\n    return modifier.performAsync(nextFn);\n  } else {\n    return value => Promise.resolve(pickFn(fn, 'async')(value));\n  }\n}\n\nexport default Rule;\n","class Modifier {\n  constructor(name, perform, performAsync) {\n    this.name = name;\n    this.perform = perform;\n    this.performAsync = performAsync;\n  }\n}\n\nexport default Modifier;\n","class ValidationError extends Error {\n  constructor(rule, value, cause, target, ...remaining) {\n    super(remaining);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ValidationError);\n    }\n    this.rule = rule;\n    this.value = value;\n    this.cause = cause;\n    this.target = target;\n  }\n}\n\nexport default ValidationError;\n","import Rule from './Rule';\nimport Modifier from './Modifier';\nimport ValidationError from './ValidationError';\n\nclass Context {\n  constructor(chain = [], nextRuleModifiers = []) {\n    this.chain = chain;\n    this.nextRuleModifiers = nextRuleModifiers;\n  }\n\n  _applyRule(ruleFn, name) {\n    return (...args) => {\n      this.chain.push(\n        new Rule(name, ruleFn.apply(this, args), args, this.nextRuleModifiers),\n      );\n      this.nextRuleModifiers = [];\n      return this;\n    };\n  }\n\n  _applyModifier(modifier, name) {\n    this.nextRuleModifiers.push(\n      new Modifier(name, modifier.simple, modifier.async),\n    );\n    return this;\n  }\n\n  _clone() {\n    return new Context(this.chain.slice(), this.nextRuleModifiers.slice());\n  }\n\n  test(value) {\n    return this.chain.every(rule => rule._test(value));\n  }\n\n  testAll(value) {\n    const err = [];\n    this.chain.forEach(rule => {\n      try {\n        rule._check(value);\n      } catch (ex) {\n        err.push(new ValidationError(rule, value, ex));\n      }\n    });\n    return err;\n  }\n\n  check(value) {\n    this.chain.forEach(rule => {\n      try {\n        rule._check(value);\n      } catch (ex) {\n        throw new ValidationError(rule, value, ex);\n      }\n    });\n  }\n\n  testAsync(value) {\n    return new Promise((resolve, reject) => {\n      executeAsyncRules(value, this.chain.slice(), resolve, reject);\n    });\n  }\n}\n\nfunction executeAsyncRules(value, rules, resolve, reject) {\n  if (rules.length) {\n    const rule = rules.shift();\n    rule._testAsync(value).then(\n      () => {\n        executeAsyncRules(value, rules, resolve, reject);\n      },\n      cause => {\n        reject(new ValidationError(rule, value, cause));\n      },\n    );\n  } else {\n    resolve(value);\n  }\n}\n\nexport default Context;\n","import Context from './Context';\n\nfunction v8n() {\n  return proxyContext(new Context());\n}\n\n// Custom rules\nlet customRules = {};\n\nv8n.extend = function(newRules) {\n  Object.assign(customRules, newRules);\n};\n\nv8n.clearCustomRules = function() {\n  customRules = {};\n};\n\nfunction proxyContext(context) {\n  return new Proxy(context, {\n    get(obj, prop) {\n      if (prop in obj) {\n        return obj[prop];\n      }\n\n      const newContext = proxyContext(context._clone());\n\n      if (prop in availableModifiers) {\n        return newContext._applyModifier(availableModifiers[prop], prop);\n      }\n      if (prop in customRules) {\n        return newContext._applyRule(customRules[prop], prop);\n      }\n      if (prop in availableRules) {\n        return newContext._applyRule(availableRules[prop], prop);\n      }\n    },\n  });\n}\n\nconst availableModifiers = {\n  not: {\n    simple: fn => value => !fn(value),\n    async: fn => value =>\n      Promise.resolve(fn(value))\n        .then(result => !result)\n        .catch(() => true),\n  },\n\n  some: {\n    simple: fn => value => {\n      return split(value).some(item => {\n        try {\n          return fn(item);\n        } catch (ex) {\n          return false;\n        }\n      });\n    },\n    async: fn => value => {\n      return Promise.all(\n        split(value).map(item => {\n          try {\n            return fn(item).catch(() => false);\n          } catch (ex) {\n            return false;\n          }\n        }),\n      ).then(result => result.some(Boolean));\n    },\n  },\n\n  every: {\n    simple: fn => value => value !== false && split(value).every(fn),\n    async: fn => value =>\n      Promise.all(split(value).map(fn)).then(result => result.every(Boolean)),\n  },\n};\n\nfunction split(value) {\n  if (typeof value === 'string') {\n    return value.split('');\n  }\n  return value;\n}\n\nconst availableRules = {\n  // Value\n\n  equal: expected => value => value == expected,\n\n  exact: expected => value => value === expected,\n\n  // Types\n\n  number: (allowInfinite = true) => value =>\n    typeof value === 'number' && (allowInfinite || isFinite(value)),\n\n  integer: () => value => {\n    const isInteger = Number.isInteger || isIntegerPolyfill;\n    return isInteger(value);\n  },\n\n  numeric: () => value => !isNaN(parseFloat(value)) && isFinite(value),\n\n  string: () => testType('string'),\n\n  boolean: () => testType('boolean'),\n\n  undefined: () => testType('undefined'),\n\n  null: () => testType('null'),\n\n  array: () => testType('array'),\n\n  object: () => testType('object'),\n\n  instanceOf: instance => value => value instanceof instance,\n\n  // Pattern\n\n  pattern: expected => value => expected.test(value),\n\n  lowercase: () => value => /^([a-z]+\\s*)+$/.test(value),\n\n  uppercase: () => value => /^([A-Z]+\\s*)+$/.test(value),\n\n  vowel: () => value => /^[aeiou]+$/i.test(value),\n\n  consonant: () => value => /^(?=[^aeiou])([a-z]+)$/i.test(value),\n\n  // Value at\n\n  first: expected => value => value[0] == expected,\n\n  last: expected => value => value[value.length - 1] == expected,\n\n  // Length\n\n  empty: () => value => value.length === 0,\n\n  length: (min, max) => value =>\n    value.length >= min && value.length <= (max || min),\n\n  minLength: min => value => value.length >= min,\n\n  maxLength: max => value => value.length <= max,\n\n  // Range\n\n  negative: () => value => value < 0,\n\n  positive: () => value => value >= 0,\n\n  between: (a, b) => value => value >= a && value <= b,\n\n  range: (a, b) => value => value >= a && value <= b,\n\n  lessThan: n => value => value < n,\n\n  lessThanOrEqual: n => value => value <= n,\n\n  greaterThan: n => value => value > n,\n\n  greaterThanOrEqual: n => value => value >= n,\n\n  // Divisible\n\n  even: () => value => value % 2 === 0,\n\n  odd: () => value => value % 2 !== 0,\n\n  includes: expected => value => ~value.indexOf(expected),\n\n  schema: schema => testSchema(schema),\n\n  // branching\n\n  passesAnyOf: (...validations) => value =>\n    validations.some(validation => validation.test(value)),\n\n  optional: (validation, considerTrimmedEmptyString = false) => value => {\n    if (\n      considerTrimmedEmptyString &&\n      typeof value === 'string' &&\n      value.trim() === ''\n    ) {\n      return true;\n    }\n\n    if (value !== undefined && value !== null) validation.check(value);\n    return true;\n  },\n};\n\nfunction testType(expected) {\n  return value => {\n    return (\n      (Array.isArray(value) && expected === 'array') ||\n      (value === null && expected === 'null') ||\n      typeof value === expected\n    );\n  };\n}\n\nfunction isIntegerPolyfill(value) {\n  return (\n    typeof value === 'number' && isFinite(value) && Math.floor(value) === value\n  );\n}\n\nfunction testSchema(schema) {\n  return {\n    simple: value => {\n      const causes = [];\n      Object.keys(schema).forEach(key => {\n        const nestedValidation = schema[key];\n        try {\n          nestedValidation.check((value || {})[key]);\n        } catch (ex) {\n          ex.target = key;\n          causes.push(ex);\n        }\n      });\n      if (causes.length > 0) {\n        throw causes;\n      }\n      return true;\n    },\n    async: value => {\n      const causes = [];\n      const nested = Object.keys(schema).map(key => {\n        const nestedValidation = schema[key];\n        return nestedValidation.testAsync((value || {})[key]).catch(ex => {\n          ex.target = key;\n          causes.push(ex);\n        });\n      });\n      return Promise.all(nested).then(() => {\n        if (causes.length > 0) {\n          throw causes;\n        }\n\n        return true;\n      });\n    },\n  };\n}\n\nexport default v8n;\n"],"names":["Rule","name","fn","args","modifiers","this","pickFn","variant","testAux","length","const","modifier","shift","nextFn","perform","testAsyncAux","performAsync","value","Promise","resolve","_test","let","slice","ex","_check","it","_testAsync","reject","then","valid","catch","Modifier","ValidationError","rule","cause","target","super","remaining","Error","captureStackTrace","Context","chain","nextRuleModifiers","executeAsyncRules","rules","v8n","proxyContext","_applyRule","ruleFn","push","apply","_applyModifier","simple","async","_clone","test","every","testAll","err","forEach","check","testAsync","customRules","context","Proxy","get","obj","prop","newContext","availableModifiers","availableRules","extend","newRules","Object","assign","clearCustomRules","not","result","some","split","item","all","map","Boolean","equal","expected","exact","number","allowInfinite","isFinite","integer","Number","isInteger","isIntegerPolyfill","numeric","isNaN","parseFloat","string","testType","boolean","undefined","null","array","object","instanceOf","instance","pattern","lowercase","uppercase","vowel","consonant","first","last","empty","min","max","minLength","maxLength","negative","positive","between","a","b","range","lessThan","n","lessThanOrEqual","greaterThan","greaterThanOrEqual","even","odd","includes","indexOf","schema","causes","keys","key","nestedValidation","nested","testSchema","passesAnyOf","validations","validation","optional","considerTrimmedEmptyString","trim","Array","isArray","Math","floor"],"mappings":"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"}